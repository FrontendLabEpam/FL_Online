<!DOCTYPE html>
<html>
<head>
    <title>Inheritance in JS</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href="../assets/css/reset.css" rel="stylesheet" type="text/css" />
    <link href="../assets/css/fonts.css" rel="stylesheet" type="text/css" />
    <link href="../assets/css/typography.css" rel="stylesheet" type="text/css" />
    <link href="../assets/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>

<div class="wrapper">
  <header class="mainheader">
    <div class="logo">
      <div class="divider"><a href="../index.html"><img src="../assets/img/Logo.png"></a></div>
      <a href="../inheritance/index.html#1"><span class="logotext">Inheritance in JS</span></a>
    </div>
  </header>
</div>

<!-- ================== Slides ================== -->
    <textarea id="source">


class: center, middle

.title[
  Front-end training
  # Inheritance
]

---

# Inheritance

Is a way to reuse code of existing objects,
or to establish a subtype from an existing object,
or both, depending upon programming language support.

---

# Reusability

Let's consider next situation:
you have 2 object to represent student and teacher.

```
var student = {
  name: 'Vasya',
  describe: function() {
    console.log(this.name);
  }
};

var teacher = {
  name: 'Vasili Alibabayevich',
  describe: function() {
    console.log(this.name);
  }
};
// ...
```

Note `describe` repeated...

---

# Reusability

Naive reuse of `describe` might look like this:

```
function describe(person) {
  console.log(person.name);
}

describe(student); // -> "Vasya"
describe(teacher); // -> "Vasili Alibabayevich"
```

But such approach will create many functions without explaining their purpose;
May lead to name conflicts and lost object context:

```
var cargo = {
  weight: 200,
  height: 100,
  width: 200
};

describe(cargo); // -> undefined // whoops...
```

---

# Prototype

Unlike "traditional" class-based approach,
JS uses constructors and `[[Prototype]]` objects as default extension mechanism.

In JavaScript, objects have a special hidden property `[[Prototype]]`, that is either `null` or references another object. That object is
called _“a prototype”_. When we want to read a property from object, and it’s missing, JavaScript automatically takes it from the
prototype (keep in mind that it is read-only, is not affected by addition, updating or deletion operations). In programming, such
thing is called _“prototypal inheritance”_. The property `[[Prototype]]` is internal and hidden which means that we can’t access it
directly, but there are many ways to get/set/check it.
* `__proto__` is a historical getter/setter for `[[Prototype]]`;
* `prototype` property of the constructor function (whenever an instance-object is returned from a function call using new, it is
given a property with the key `__proto__`. The value of this property is the prototype property of the function that created it.)
* `Object.create()`;
* `Object.setPrototypeOf()`; // not recommended
* `Object.getPrototypeOf()` - returns the the value of the internal `[[Prototype]]` property of the specified object;
* `Object.prototype.isPrototypeOf()` - checks if an object exists in another object's prototype chain.

---
##Prototypal Inheritance: `__proto__` Example

`__proto__` is a historical getter/setter for `[[Prototype]]`.

```javascript
const user = {
  login: 'Anonymous',
  email: 'anonymous@test.com',
  password: '*******'
};

const guest = {
  isAdmin: false
};

// set [[Prototype]] to be user
guest.__proto__ = user;

// now all methods and properties of user are available for guest (read-only mode)
guest.email // 'anonymous@test.com'

// delete operation does not affect prototype
delete guest.email
guest.email // 'anonymous@test.com'
// changes does not affect prototype as well
guest.email = 'guest@test.com' // sets emails property on guest, no changes for user
```
__Note!__ Modifying `__proto__` directly is considered to be a bad practice.

---
## Prototypal Inheritance: `Object.setPrototypeOf()` Example

```javascript
const user = {
  login: 'Anonymous',
  email: 'anonymous@test.com',
  password: '*******'
};
const guest = {
  isAdmin: false
};

// check current [[Prototype]] value
Object.getPrototypeOf(guest);
Object.prototype.isPrototypeOf(guest); // true
user.isPrototypeOf(guest); //false

// set [[Prototype]] to be user
Object.setPrototypeOf(guest, user);
// now all methods and properties of user are available for guest (read-only mode)
guest.email // 'anonymous@test.com'

// check new [[Prototype]] value
Object.getPrototypeOf(guest);  // it will be user object itself
user.isPrototypeOf(guest); // true
```
__Note!__ Modifying the `[[Prototype]]` with `Object.setPrototypeOf()` is considered to be a bad practice.

---
##Prototypal Inheritance: `Object.create()` Example

`Object.create()` creates a new object, using an existing object as the prototype of the newly created object ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)).

```javascript
const user = {
  login: 'Anonymous',
  email: 'anonymous@test.com',
  password: '*******'
};

const guest = Object.create(user, {
  isAdmin: {
    value: false,
    enumerable: true,
    configurable: true,
    writable: true
  }
});

guest // { isAdmin: false }
guest.email  // 'anonymous@test.com'
```

So, we have got an object that is now `[[Prototype]]`-linked to the newly created object.
That linkage gives it access to all methods and properties that exist on its prototype and on its prototype's prototype and so on till the end of the prototypal chain (no matter how long it is) but only  in read-only mode.

---

# Inheritance example

```javascript
const Person = function(name) {
  this.name = name;
};
Person.prototype.greet = function() {
  console.log('Hi, I am ' + this.name);
};
const Employee = function(name, title) {
  Person.call(this, name);
  this.title = title;
};
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;
Employee.prototype.greet = function() {
  console.log('Hi, I am ' + this.name + ', the ' + this.title);
};
const Customer = function(name, money) {
  Person.call(this, name);
  this.money = money;
};
Customer.prototype = Object.create(Person.prototype);
Customer.prototype.constructor = Customer;

const bob = new Employee('Bob', 'Builder'); bob.greet(); // Hi, I am Bob, the Builder
const joe = new Customer('Joe', 2000);  joe.greet(); // Hi, I am Joe
const rg = new Employee('Red Green', 'Handyman'); rg.greet(); // Hi, I am Red Green, the Handyman
```

---

# ES2015 version

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() { console.log('Hi, I am ' + this.name); }
}
class Employee extends Person {
  constructor(name, title) {
    super(name);
    this.title = title;
  }
  greet() { console.log('Hi, I am ' + this.name + ', the ' + this.title); }
}
class Customer extends Person {
  constructor(name, money) {
    super(name);
    this.money = money;
  }
}
var bob = new Employee('Bob', 'Builder'); bob.greet(); // Hi, I am Bob, the Builder
var joe = new Customer('Joe', 2000);  joe.greet(); // Hi, I am Joe
var rg = new Employee('Red Green', 'Handyman'); rg.greet(); // Hi, I am Red Green, the Handyman
```

---

# Change prototype properties

When you change prototype object - all childs are automatically updated:

```
function Dog(name) {
  this.name = name;
}

const fido = new Dog('Fido');
const shiba = new Dog('Shiba');
fido.sayName(); // -> dog.sayName is not a function

Dog.prototype.sayName = function() {
  console.log(this.name);
};

fido.sayName(); // Fido
shiba.sayName(); // Shiba
```
---

# Change prototype properties (cont.)

But notice, that when you change properties of specific prototype - only that
constructor childs updated:

```
function Animal() {}

function Cat(name) { this.name = name; }

Cat.prototype = Object.create(Animal.prototype);
Cat.prototype.constructor = Animal;

function Dog(name) { this.name = name; }

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Animal;

const cat = new Cat('Kitty');
const dog = new Dog('Fido');

Dog.prototype.woof = function() {
  console.log(this.name + ' say "woof"');
};

dog.woof(); // "woof"
cat.woof(); // TypeError: undefined is not a function
```

---

# Detect property source

You can find out where property or method comes from - object itself or prototype;
by using `hasOwnProperty(key)`.

```
cat.hasOwnProperty('name'); // true
cat.hasOwnProperty('sayName'); // false
```

Prototype methods and properties are captured by `for..in` loop,
so if you don't need them - use `hasOwnProperty`.

```
for (var key in cat) {
  console.log(key);
} // name, sayName
```

```
for (var key in cat) {
  if (cat.hasOwnProperty(key))
    console.log(key);
} // name
```
---

# Sensitive data in prototypes

Never store data that may change in prototype

```
function Animal() {}
// "sensitive" data
Animal.prototype.items = [];

function Cat(name) {
  this.name = name;
}

Cat.prototype = Object.create(Animal.prototype);
Cat.prototype.constructor = Cat;
Cat.prototype.give = function(item) {
  this.items.push(item);
};

const kitty = new Cat('kitty');
const cat = new Cat('cat');
cat.give('food');
cat.items; // ['food']
kitty.items; // ['food'] -> bad, we didn't give anything to kitty
```
---

# Method override

If you need to change an object behaviour - you can rewrite prototype's object method:

```
...
Cat.prototype.sayName = function() {
  return `cat meows ${this.name}`;
};

const cat = new Cat('Kitty');
const dog = new Dog('Fido');

dog.sayName(); // Fido
cat.sayName(); // cat meows "Kitty"
```

Also you can change properties only for object:
```
const fido = new Dog('Fido');
const shiba = new Dog('Shiba');

shiba.woof = function() {
  console.log("wow, so woof, many sound");
};

fido.woof(); // Fido say "woof"
shiba.woof(); // wow, so woof, many sound
```

---

# Standard objects prototypes

Also you may add some methods to existing types:

```
String.prototype.isString = true;
Array.prototype.isArray = true;
Number.prototype.isNumber = true;

(1).isNumber // true
[].isArray // true
''.isString // true
```

All js objects has Object as prototype. You may define some behaviour for _all_
object using `Object.prototype`. For example add method to get unique id of
object:

```
Object.prototype.getId = function() {
  if (!this.___uniq_id) {
    this.___uniq_id = Math.round(Math.random() * 100500));
  }
  return this.___uniq_id;
};
var a = 1;
a.getId(); // -> some random id
```

---
# instanceof Operator

The `instanceof` operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof)).

```
class Animal {
  constructor(name) {
    this.name = name;
  }
}

class Cat extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }
}

const kitty = new Cat('Kitty', 'persian');

kitty instanceof Cat; //true
kitty instanceof Animal; // true as well
```

---
## But where exactly does the [[Prototype]] chain "end" ?

The top-end of every *normal* `[[Prototype]]` chain is the built-in `Object.prototype`. This object
includes a variety of common utilities used all over JS, because all normal objects in JavaScript "descend from"
the `Object.prototype` object.

.img-wrap-40[![chain](inheritance.png)]

---

# Resources

- [Object-Oriented JavaScript](https://classroom.udacity.com/courses/ud711)
- [Understanding "Prototypes" in JavaScript](http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/)
- [Prototypes, inheritance](https://javascript.info/prototypes)
- [Classes](https://javascript.info/classes)
- [Common misconceptions about inheritance in js](https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a)
- [Decoding the Prototypal Inheritance in JavaScript](https://medium.com/@Gaurav.Chaudhary/decoding-the-prototypal-inheritance-in-javascript-everything-you-need-to-know-9c56bfc32129)
- [A Beginner's Guide to JavaScript's Prototype](https://tylermcginnis.com/beginners-guide-to-javascript-prototype/)
- [JavaScript Private and Public Class Fields](https://tylermcginnis.com/javascript-private-and-public-class-fields/)
- [JavaScript Inheritance and the Prototype Chain](https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/)
- [JavaScript Inheritance vs Composition](https://tylermcginnis.com/javascript-inheritance-vs-composition/)
- [Composition over Inheritance (video, 8min)](https://www.youtube.com/watch?v=wfMtDGfHWpA)
- [Object Playground](http://www.objectplayground.com/)

---
class: center, middle

.title[
## Thank you!
]

    </textarea>
<!-- ================== End of Slides ================== -->

    <script src="../assets/js/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">remark.create({
      highlightStyle: 'github',
      highlightLanguage: 'javascript'
    });</script>
</body>
</html>
