<!DOCTYPE html>
<html>
<head>
  <title>Functions</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link href="../assets/css/reset.css" rel="stylesheet" type="text/css" />
  <link href="../assets/css/fonts.css" rel="stylesheet" type="text/css" />
  <link href="../assets/css/typography.css" rel="stylesheet" type="text/css" />
  <link href="../assets/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>

<div class="wrapper">
  <header class="mainheader">
    <div class="logo">
      <div class="divider"><a href="../index.html"><img src="../assets/img/Logo.png"></a></div>
      <a href="../functions_pt1/index.html#1"><span class="logotext">Functions. Advanced.</span></a>
    </div>
  </header>
</div>
<!-- ================== Slides ================== -->
<textarea id="source">

class: center, middle

.title[
Front-end training
# Functions Advanced
]

---
  # Scope again

  1. Scope in an object, it's created at function call (activation object)
  2. All variables and functions become properties of scope object

  ```
    function parentFunction() {
        // parentFunction scope created. vairable and child function become its properties
        /*
            scope: {
              variable: undefined,
              childFunction: childFunction
            }
        */
        var variable = 10;
        function childFunction() {
              // Something useful here
        }

    }
    parentFunction();
  ```

---
# Function parent scope

 Function, as an object, has a special property [[Scope]].<br>
 When function is **declared** - two things happen:<br>
   1. function becomes a property of scope object<br>
   2. current scope object is written to [[Scope]] property of function object<br>
<br>
```
    function parentFunction() {
        // parentFunction scope created.
        /*
            1. Child function becomes its property
            scope: {
              childFunction: childFunction
            }

            2. Scope becomes a property of child function
            childFunction.[[Scope]] = scope
        */
        function childFunction() {
              // Something useful here
        }
    }
    parentFunction();
```

---

# Closure

When function "knows" the scope where it was declared - we call it "closure"<br>
As [[Scope]] is a property of function object itself - even if we return function and call it at any other place in the code - it will remember scope  where it was declared<br>


```
    function parent() {
        let childCallCount = 0;
        function child() {
            childCallCount++;
            console.log(`called ${childCallCount} time(s)`);
        }

        child();
        return child;
    }

    let childFirst = parent(); // called 1 time(s)
    childFirst(); // called 2 time(s)
    childFirst(); // called 3 time(s)

    let childSecond = parent();// called 1 time(s)
    childSecond(); // called 2 time(s)
    childSecond(); // called 3 time(s)

```

---

# Scope chain. Variable lookup

1. Folded functions create a chain of scopes
2. When we are trying to access a variable - JS will seek it in current scope and up through the chain
3. We can "hide" the parent variable by declaration a new variable with the same name
3. If no variable declaration were found - exception will occur
```
    function parent() {
        let parentProperty = 10;
        function child() {
            console.log(parentProperty);  // 10
        }
        child();

        function childHidesParentProperty() {
            let parentProperty = 20;
            function childOfAChild() {
                console.log(parentProperty); // 20
            }
            childOfAChild();
        }
        childHidesParentProperty();
    }
    parent();
```

---

# Parent scope is shared between child functions

It's really obvious, but let's see:
```
    function getCounter() {
        let counter = 0;
        function increment(incrementBy) {
            if (typeof incrementBy === 'undefined') {
                incrementBy = 1;
            }
            counter = counter + incrementBy;
        }
        function decrement(decrementBy) {
            if (typeof decrementBy !== 'number') {
                decrementBy = 1;
            }
            counter = counter - decrementBy;
        }
        function printCounter() {
            console.log('Current value is: ' + counter);
        }
        return {
            inc: increment,
            dec: decrement,
            print: printCounter
        }
    }

```
---
# Parent scope is shared between child functions (cont.)

```
    let counter = getCounter();
    counter.inc(10);
    counter.print(); // 10
    counter.dec();
    counter.print(); // 9
```
---
# Parent scope is shared between child functions ES6 example

```
    function getCounter() {
        let counter = 0;
        return {
            inc: (incrementBy = 1) => counter += incrementBy,
            dec: (decrementBy = 1) => counter -= decrementBy,
            print: () => console.log(`Current value is: ${counter}`)
        }
    }
    let counter = getCounter();
    counter.inc(10);
    counter.inc();
    counter.print(); // 10
    counter.dec();
    counter.print(); // 9
```

---
# Summarize

1. Each function object gets a link to a scope where it was declared - closure
2. JS seeks variable value up through scopes chain
3. If we declare variable with the same name in child scope it will hide parent variable from us
4. But only in current function. Scope is shared between child functions, they will  have access to parent variable

---

# Hoisting again.
1. var, let, const and function are hoisted
2. This is done to "hide" parent scope variables to avoid confusion (or to create one)
3. **var** is hoisted in a whole function scope

```
    var parentPropertyVar = 'var';

    function hoistingExample() {
        console.log('value: ', parentPropertyVar);  // undefined
        var parentPropertyVar = 'hidden var';
        console.log('value: ', parentPropertyVar); // 'hidden var'
    }

    console.log('value: ', parentPropertyVar); // var
    hoistingExample();
```

---

# Hoisting of let and const
1. **let** and **const** are hoisted in a block code scope: { ... }
2. Trying to access a variable before the declaration produces an error
3. Error occurs because variable is in so called Temporary Dead Zone

```
    let parentPropertyLet = 'let';

    function hoistingExample(hideParentProperty) {
         if (hideParentProperty) {
            // console.log('value: ', parentPropertyLet);  -> will produce an error
            let parentPropertyLet = 'hidden let';
            console.log('value: ', parentPropertyLet);
        } else {
            console.log('value: ', parentPropertyLet);
        }
    }
    hoistingExample(false);
    hoistingExample(true);
```

---

# Call stack

1. Call stack holds the ordered list of called functions.
2. When function returns the result - it is removed from stack
3. When the error occurs we can see the current call stack - useful for debugging

```
    secondInStack();

    function secondInStack() {
        thirdInStack();
    }

    function thirdInStack() {
        console.log("I'm the third!");
    }

```

---

# Recursion

1. Recursion is an operation when function can call itself once again.
2. Can be useful for parsing, tree walking
3. Call stack is not endless
4. Any recursion can be changed to loop

```
    const usefulStorage = [1, 2, 3];

    popFromStorage(usefulStorage);
    // Item:  3
    // Item:  2
    // Item:  1
    // Storage is empty!

    function popFromStorage(storage) {
        let item = storage.pop();
        console.log("Item: ", item);
        if (storage.length > 0) {
            popFromStorage(storage);
        } else {
            console.log("Storage is empty!");
        }
    }


```

---

# Function execution context. This.

The environment in which function is executed is called **function execution context**<br>
It consists of:
1. Function scope
2. Function parent scope (the whole chain)
3. "arguments" property
4. "this" keyword - often is called "function context"
5. Exact value of "this" is defined when the function is called

```
    function showContext() {
        console.log(this);  // 'window' in browser
    }
    showContext();
```

---

# When function is a method of an object

1. We say "object has a method" when a **value** of its property is a **function**
2. someObject.method() - is just a way to set a function context

```
    const counter = {
        currentValue: 100,
        print: function() {
            console.log(this.currentValue);
        }
    }

    counter.print();  // function context is "counter" object

    let printFunction = counter.print;
    printFunction();  // function context is Window
```

---

# Call and apply methods of a function

1. Any function is an object itself
2. It has special methods **call** and **apply** to execute a function
3. Apply: A - for array

```
    const counter = {
        currentValue: 100,
        print: function(message) {
            console.log(message, this.currentValue);
        }
    }

    counter.print("Value: ");  // function context is "counter" object

    let printFunction = counter.print;
    printFunction();  // function context is Window

    printFunction.call(counter, "Value: ");  // function context is a "counter" object again

    printFunction.apply(counter, ["Value: "]);  // function context is a "counter" object again
```

---

# Bind method of a function

1. A special method which "binds" a specified context for the all future function calls
2. bind method returns a **new** instance of function
3. Even some additional params can be bound
4. They **can not** be changed for a bound function
5. But we can call bind method for inital function once again to get another instance of bound function

```
    const counter = {
        currentValue: 100,
        print: undefined
    }

    counter.print = (function(message) {
        console.log(message, this.currentValue);
    }).bind(counter, "Value: ");

    counter.print();  // function context is "counter" object
    let printFunction = counter.print;
    printFunction("I want another message!!!");  // context is "counter", message is "Value: "

    let anotherPrintFunction = printFunction.bind(window);
    anotherPrintFunction();  // function context is "counter" object

```

---

# When function is a constructor.

1. We say "constructor function" when we use operator "new" with it and receive a new object instance
2. Is is almost the same like to use .call({}, ...);

```
    function Counter(initialValue) {
        this.currentValue = initialValue,
        this.print = function() {
            console.log(this.currentValue);
        }
    }

    const counter = new Counter(50);
    counter.print();  // function context is "counter" object

    const counter2 = {};
    Counter.call(counter2, 60); // function context is "counter2" object - empty object
    counter2.print();


```

---

# ES6 arrow function and execution context

1. Arrow function is always "bound" to current value of this
2. It has no "arguments" object

```
    function Counter(initialValue) {
        this.currentValue = initialValue,
        this.print = () => {
            console.log(this.currentValue);
        }
    }

    const counter = new Counter(50);
    counter.print();  // function context is "counter" object
    let printFunction = counter.print;
    printFunction();  // function context is still a "counter" object

```

---

# bind function polyfill
Requirements
1. it should accept initial function and context (lets skip additional params for simplicity)
2. it should return a new function
3. when returned function is called - initial function should be called with bound values
4. Closure!


```
    function bind(initialFunction, context) {
        let boundedFunction = function() {
            return initialFunction.apply(context);
        }
        return boundedFunction;
    }

    const bindMe = function() {
        console.log(this.name);
    }

    const context = {name: 'Kostya'};

    const bounded = bind(bindMe, context);
    bounded();

```

---


# Links

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures
- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this
- https://developer.mozilla.org/ru/docs/Glossary/Call_stack
- http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/

</textarea>
<!-- ================== End of Slides ================== -->

    <script src="../assets/js/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">remark.create({
      highlightStyle: 'github',
      highlightLanguage: 'javascript'
    });</script>
</body>
</html>